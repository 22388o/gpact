package main

/*
 * Copyright 2021 ConsenSys Software Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

import (
	"context"
	"crypto/ecdsa"
	"fmt"
	"math/big"
	"time"

	"github.com/consensys/gpact/messaging/relayer/internal/crypto"
	"github.com/consensys/gpact/messaging/relayer/internal/mqserver"
	"github.com/consensys/gpact/messaging/relayer/internal/soliditywrappers/application"
	"github.com/consensys/gpact/messaging/relayer/internal/soliditywrappers/erc20"
	"github.com/consensys/gpact/messaging/relayer/internal/soliditywrappers/eventstore"
	"github.com/consensys/gpact/messaging/relayer/internal/soliditywrappers/registrar"
	"github.com/consensys/gpact/messaging/relayer/internal/soliditywrappers/sfc"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto/secp256k1"
	"github.com/ethereum/go-ethereum/ethclient"
	_ "github.com/joho/godotenv/autoload"
)

// TODO, Need a separate package to put all core components.
var s *mqserver.MQServer

func main() {

	conn, err := ethclient.Dial("ws://127.0.0.1:8311/")
	if err != nil {
		panic(err)
	}
	defer conn.Close()

	// Contract owner...
	key, err := crypto.Secp256k1GenerateKey()
	if err != nil {
		panic(err)
	}
	// fmt.Println(hex.EncodeToString(key))
	pub := crypto.Secp256k1PublicKey(key)
	addr := common.BytesToAddress(crypto.Keccak256(pub[1:])[12:])
	fmt.Println(addr)

	// Create the same key
	x, y := secp256k1.S256().ScalarBaseMult(key)
	prv := &ecdsa.PrivateKey{}
	prv.D = big.NewInt(0).SetBytes(key)
	prv.PublicKey = ecdsa.PublicKey{
		X:     x,
		Y:     y,
		Curve: secp256k1.S256(),
	}
	// fmt.Println("1 curve", prv.PublicKey)

	auth := bind.NewKeyedTransactor(prv)
	auth.Nonce = big.NewInt(int64(0))
	auth.Value = big.NewInt(0)      // in wei
	auth.GasLimit = uint64(3000000) // in units
	auth.GasPrice = big.NewInt(0)

	// First of all, deploy erc20 fixed
	addr0, tx, ierc20, err := erc20.DeployERC20PresetFixedSupply(auth, conn, "chainA", "chainA", big.NewInt(100000), auth.From)
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)
	fmt.Println("ERC20 address: ", addr0)
	// Secondly, deploy sfc contract
	auth.Nonce.Add(auth.Nonce, big.NewInt(1))
	addr1, tx /*isfc*/, _, err := sfc.DeploySfc(auth, conn, big.NewInt(31), big.NewInt(100000))
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)
	fmt.Println("SFC cbc address:", addr1)
	// Thirdly, deploy bridge.
	auth.Nonce.Add(auth.Nonce, big.NewInt(1))
	addr2, tx, ibridge, err := application.DeploySfcERC20Bridge(auth, conn, addr1)
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)
	fmt.Println("Bridge address: ", addr2)

	sink := make(chan *application.SfcERC20BridgeTransferTo)
	event, err := ibridge.WatchTransferTo(&bind.WatchOpts{Start: nil, Context: nil}, sink)
	if err != nil {
		panic(err)
	}
	end := make(chan bool)
	go func() {
		fmt.Println("Start watching...")
		for {
			select {
			case err := <-event.Err():
				fmt.Printf("Error from watch: %v\n", err.Error())
			case log := <-sink:
				fmt.Println(log)
			case <-end:
				fmt.Println("exit")
				return
			}
		}
	}()

	// Fourth, deploy registrar.
	auth.Nonce.Add(auth.Nonce, big.NewInt(1))
	addr3, tx, _ /*ireg*/, err := registrar.DeployRegistrar(auth, conn)
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)
	fmt.Println("Registrar address: ", addr3)
	// Fifth, deploy event store/verifier
	auth.Nonce.Add(auth.Nonce, big.NewInt(1))
	addr4, tx /*iverifier*/, _, err := eventstore.DeployEventStore(auth, conn, addr3, addr1)
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)
	fmt.Println("Event store address: ", addr4)

	// Sixth, change chain mapping
	fmt.Println("Change blockchain mappping")
	auth.Nonce.Add(auth.Nonce, big.NewInt(1))
	tx, err = ibridge.ChangeBlockchainMapping(auth, big.NewInt(33), common.HexToAddress("0x8e215d06ea7ec1fdb4fc5fd21768f4b34ee90123"))
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)

	fmt.Println("Add contract mapping...")
	auth.Nonce.Add(auth.Nonce, big.NewInt(1))
	tx, err = ibridge.AddContractFirstMapping(auth, addr0, big.NewInt(33), common.HexToAddress("0x8e215d06ea7ec1fdb4fc5fd21768f4b34ee90124"), true)
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)

	// Create some user
	key2, err := crypto.Secp256k1GenerateKey()
	if err != nil {
		panic(err)
	}
	// fmt.Println(hex.EncodeToString(key))
	pub2 := crypto.Secp256k1PublicKey(key2)
	userAddr := common.BytesToAddress(crypto.Keccak256(pub2[1:])[12:])

	// Create the same key
	x, y = secp256k1.S256().ScalarBaseMult(key2)
	prv2 := &ecdsa.PrivateKey{}
	prv2.D = big.NewInt(0).SetBytes(key2)
	prv2.PublicKey = ecdsa.PublicKey{
		X:     x,
		Y:     y,
		Curve: secp256k1.S256(),
	}
	// fmt.Println("1 curve", prv.PublicKey)
	auth2 := bind.NewKeyedTransactor(prv2)
	auth2.Nonce = big.NewInt(int64(0))
	auth2.Value = big.NewInt(0)      // in wei
	auth2.GasLimit = uint64(3000000) // in units
	auth2.GasPrice = big.NewInt(0)

	test, err := ierc20.BalanceOf(nil, userAddr)
	fmt.Println(err)
	fmt.Println(test)

	// Transfer to this user some balance
	fmt.Println("Transfer...")
	auth.Nonce.Add(auth.Nonce, big.NewInt(1))
	tx, err = ierc20.Transfer(auth, userAddr, big.NewInt(200))
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)

	test, err = ierc20.BalanceOf(nil, userAddr)
	fmt.Println(err)
	fmt.Println(test)

	// Seventh.
	fmt.Println("Approve...")
	tx, err = ierc20.Approve(auth2, addr2, big.NewInt(200))
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)

	// Crosschain call
	fmt.Println("Crosschain call")
	auth2.Nonce.Add(auth2.Nonce, big.NewInt(1))
	tx, err = ibridge.TransferToOtherBlockchain(auth2, big.NewInt(100), addr0, common.HexToAddress("0x8e215d06ea7ec1fdb4fc5fd21768f4b34ee92ef4"), big.NewInt(100))
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)

	end <- true
	time.Sleep(1 * time.Second)
}

func waitForReceipt(conn *ethclient.Client, tx *types.Transaction) {
	for {
		rept, err := conn.TransactionReceipt(context.Background(), tx.Hash())
		if err == nil {
			if rept.Status != types.ReceiptStatusSuccessful {
				fmt.Println("Transaction failed.")
				fmt.Println(rept)
			} else {
				fmt.Println("Transaction succeed.")
			}
			break
		}
		time.Sleep(1 * time.Second)
	}
}

func createUser() *bind.TransactOpts {
	key, err := crypto.Secp256k1GenerateKey()
	if err != nil {
		panic(err)
	}
	// Create the same key
	x, y := secp256k1.S256().ScalarBaseMult(key)
	prv := &ecdsa.PrivateKey{}
	prv.D = big.NewInt(0).SetBytes(key)
	prv.PublicKey = ecdsa.PublicKey{
		X:     x,
		Y:     y,
		Curve: secp256k1.S256(),
	}
	auth := bind.NewKeyedTransactor(prv)
	auth.Nonce = big.NewInt(int64(0))
	auth.Value = big.NewInt(0)      // in wei
	auth.GasLimit = uint64(3000000) // in units
	auth.GasPrice = big.NewInt(0)
	return auth
}

func main() {
	conn, err := ethclient.Dial("ws://127.0.0.1:8311/")
	if err != nil {
		panic(err)
	}
	defer conn.Close()

	// Create an admin user
	adminAuth := createUser()

	// Deploy erc20 contract on chain
	fmt.Println("Deploy ERC20 contract on chain...")
	erc20Addr, tx, ierc20, err := erc20.DeployERC20PresetFixedSupply(adminAuth, conn, "chainA", "chainA", big.NewInt(10000), adminAuth.From)
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)
	fmt.Println("ERC20 contract deployed at: ", erc20Addr)
	adminAuth.Nonce.Add(adminAuth.Nonce, big.NewInt(1))

	// Deploy SFC contract
	fmt.Println("Deploy SFC contract on chain...")
	sfcAddr, tx, _, err := sfc.DeploySfc(adminAuth, conn, big.NewInt(31), big.NewInt(100000))
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)
	fmt.Println("SFC contract deployed at: ", sfcAddr)
	adminAuth.Nonce.Add(adminAuth.Nonce, big.NewInt(1))

	// Deploy erc20 bridge
	fmt.Println("Deploy bridge contract on chain...")
	bridgeAddr, tx, ibridge, err := application.DeploySfcERC20Bridge(adminAuth, conn, sfcAddr)
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)
	fmt.Println("Bridge contract deployed at: ", bridgeAddr)
	adminAuth.Nonce.Add(adminAuth.Nonce, big.NewInt(1))

	// Create two users
	user1 := createUser()
	fmt.Println("Create user1 at chainA with address: ", user1.From)
	user2 := createUser()
	fmt.Println("Create user2 at chainB with address: ", user2.From)

	// Transfer some token to user1.
	fmt.Println("Transfer token to user1...")
	tx, err = ierc20.Transfer(adminAuth, user1.From, big.NewInt(200))
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)
	adminAuth.Nonce.Add(adminAuth.Nonce, big.NewInt(1))
	fmt.Println("Transfer done.")

	// Setup for crosschain transfer
	fmt.Println("Change blockchain mapping...")
	tx, err = ibridge.ChangeBlockchainMapping(adminAuth, big.NewInt(32), common.HexToAddress("0x8e215d06ea7ec1fdb4fc5fd21768f4b34ee90123"))
	waitForReceipt(conn, tx)
	adminAuth.Nonce.Add(adminAuth.Nonce, big.NewInt(1))
	fmt.Println("Change blockchain mapping done.")

	fmt.Println("Add contract first mapping...")
	tx, err = ibridge.AddContractFirstMapping(adminAuth, erc20Addr, big.NewInt(32), common.HexToAddress("0x8e215d06ea7ec1fdb4fc5fd21768f4b34ee90124"), true)
	waitForReceipt(conn, tx)
	adminAuth.Nonce.Add(adminAuth.Nonce, big.NewInt(1))
	fmt.Println("Add contract first mapping done.")

	fmt.Println("Approve...")
	tx, err = ierc20.Approve(user1, bridgeAddr, big.NewInt(50))
	if err != nil {
		panic(err)
	}
	user1.Nonce.Add(user1.Nonce, big.NewInt(1))
	fmt.Println("Approved.")

	sink := make(chan *application.SfcERC20BridgeTransferTo)
	event, err := ibridge.WatchTransferTo(&bind.WatchOpts{Start: nil, Context: nil}, sink)
	if err != nil {
		panic(err)
	}
	end := make(chan bool)
	go func() {
		fmt.Println("Start watching...")
		for {
			select {
			case err := <-event.Err():
				fmt.Printf("Error from watch: %v\n", err.Error())
			case log := <-sink:
				fmt.Println(log)
			case <-end:
				fmt.Println("exit")
				return
			}
		}
	}()

	// User 1 do crosschain transfer
	tx, err = ibridge.TransferToOtherBlockchain(user1, big.NewInt(32), erc20Addr, user2.From, big.NewInt(50))
	if err != nil {
		panic(err)
	}
	waitForReceipt(conn, tx)

	end <- true
	time.Sleep(1 * time.Second)
}
